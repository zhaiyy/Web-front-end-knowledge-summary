# 闭包
## 什么是闭包 
闭包是一个可以访问外部作用域的内部函数，即使这个外部作用域已经执行结束。

换句话讲

*闭包就是能够读取其他函数内部变量的函数。*

* JavaScript 语序引用在当前函数以外定义的变量
* 即使外部函数已经返回，当前函数依旧可以使用在外部函数所定义的变量
* 闭包比创建他们的函数有更长的生命周期
* 闭包在内部存储器外部变量的引用，并能够读写这些变量

### 嵌套作用域
在 Javascript 中函数里面可以嵌套函数，如下：
```JS
(function autorun(){
    let x = 1;
    function log(){ 
       console.log(x); 
    }
    log();
})();
```
log() 即是一个嵌套在 autorun() 函数里面的函数。在 log() 函数里面可以通过外部函数访问到变量 x。此时，log() 函数就是一个闭包。

#### 外部函数作用域
内部函数可以访问外部函数中定义的变量，即使外部函数已经执行完毕。如下：

```JS
(function autorun(){
    let x = 1;
    setTimeout(function log(){
      console.log(x);
    }, 10000);
})();

```
变量 x 将一直存活着直到定时器的回调执行或者 clearTimeout() 被调用。 如果这里使用的是 setInterval() ，那么变量 x 将一直存活到 clearInterval() 被调用。

#### 外部块作用域
内部函数可以访问外部块中定义的变量，即使外部块已执行完毕，如下：

```JS
{
    let x = 1;
    setTimeout(function log(){
      console.log(x);
    }, 10000);
}

```
### 词法作用域
词法作用域是指内部函数在定义的时候就决定了其外部作用域。
```JS
(function autorun(){
    let x = 1;
    function log(){
      console.log(x);
    };
    
    function run(fn){
      let x = 100;
      fn();
    }
    
    run(log);//1
})();

```
log() 函数是一个闭包，它在这里访问的是 autorun() 函数中的 x 变量，而不是 run 函数中的变量。
*闭包的外部作用域是在其定义的时候已决定，而不是执行的时候。*
autorun() 的函数作用域即是 log() 函数的词法作用域。


## 闭包与循环
闭包只存储外部变量的引用，而不会拷贝这些外部变量的值。 查看如下示例：

```JS
function initEvents(){
  for(var i=1; i<=3; i++){
    $("#btn" + i).click(function showNumber(){
      alert(i);//4
    });
  }
}
initEvents();

```
在这个示例中，我们创建了3个闭包，皆引用了同一个变量 i，且这三个闭包都是事件处理函数。由于变量 i 随着循环自增，因此最终输出的都是同样的值。
修复这个问题最简单的方法是在 for 语句块中使用 let 变量声明，这将在每次循环中为 for 语句块创建一个新的局部变量。如下：

```JS
function initEvents(){
  for(let i=1; i<=3; i++){
    $("#btn" + i).click(function showNumber(){
      alert(i);//1 2 3
    });
  }
}
initEvents();

```
## 闭包的特性：

①.封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口；
②.持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在
系统中，闭包中的数据依然存在，从而实现对数据的持久使用。

## 优点：

① 减少全局变量。

② 减少传递函数的参数量

③ 封装；

## 闭包的风险:

 由于闭包会使得函数中的变量会被更长时间保存在内存中，消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中更是可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

## 参考文章
[[译]发现 JavaScript 中闭包的强大威力](https://juejin.im/post/6844903769646317576)
[我从来不理解JavaScript闭包，直到有人这样向我解释它...](https://zhuanlan.zhihu.com/p/56490498)
[破解前端面试（80% 应聘者不及格系列）：从闭包说起](https://juejin.im/post/6844903474212143117#heading-0)